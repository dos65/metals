package scala.meta.internal.mtags

import java.nio.CharBuffer
import java.nio.charset.StandardCharsets
import java.util.zip.ZipError

import scala.collection.concurrent.TrieMap
import scala.util.Properties
import scala.util.control.NonFatal

import scala.meta.Dialect
import scala.meta.inputs.Input
import scala.meta.internal.io.PathIO
import scala.meta.internal.io._
import scala.meta.internal.io.{ListFiles => _}
import scala.meta.internal.mtags.MtagsEnrichments._
import scala.meta.internal.semanticdb.Scala._
import scala.meta.internal.{semanticdb => s}
import scala.meta.io.AbsolutePath

/**
 * An implementation of GlobalSymbolIndex with fast indexing and low memory usage.
 *
 * Fast indexing is enabled by ScalaToplevelMtags, a custom parser that extracts
 * only toplevel symbols from a Scala source file. Java source files don't need indexing
 * because their file location can be inferred from the symbol with the limitation
 * that it doesn't work for Java source files with multiple package-private top-level classes.
 *
 * Low memory usage is enabled by only storing "non-trivial toplevel" symbols.
 * A symbol is "toplevel" when its owner is a package. A symbol is "non-trivial"
 * when it doesn't match the path of the file it's defined in, for example `Some#`
 * in Option.scala is non-trivial while `Option#` in Option.scala is trivial.
 *
 * @param toplevels keys are non-trivial toplevel symbols and values are the file
 *                  the symbols are defined in.
 * @param definitions keys are global symbols and the values are the files the symbols
 *                    are defined in. Difference between toplevels and definitions
 *                    is that toplevels contains only symbols generated by ScalaToplevelMtags
 *                    while definitions contains only symbols generated by ScalaMtags.
 */
final class OnDemandSymbolIndex(
    val toplevels: TrieMap[String, Set[AbsolutePath]] = TrieMap.empty,
    definitions: TrieMap[String, Set[AbsolutePath]] = TrieMap.empty,
    onError: PartialFunction[Throwable, Unit] = PartialFunction.empty,
    toIndexSource: AbsolutePath => Option[AbsolutePath] = _ => None
) extends GlobalSymbolIndex {
  val mtags = new Mtags
  private val sourceJars = new ClasspathLoader()
  var indexedSources = 0L
  def close(): Unit = sourceJars.close()
  private val onErrorOption = onError.andThen(_ => None)

  override def definition(symbol: Symbol): Option[SymbolDefinition] = {
    try findSymbolDefinition(symbol, symbol).headOption
    catch onErrorOption
  }

  override def definitions(symbol: Symbol): List[SymbolDefinition] =
    try findSymbolDefinition(symbol, symbol)
    catch onError.andThen(_ => List.empty)

  override def addSourceDirectory(
      dir: AbsolutePath,
      dialect: Dialect
  ): List[(String, AbsolutePath)] =
    tryRun(
      List.empty, {
        if (sourceJars.addEntry(dir)) {
          dir.listRecursive.toList.flatMap {
            case source if source.isScala =>
              addSourceFile(source, Some(dir), dialect).map(sym =>
                (sym, source)
              )
            case _ =>
              List.empty
          }
        } else
          List.empty
      }
    )

  // Traverses all source files in the given jar file and records
  // all non-trivial toplevel Scala symbols.
  override def addSourceJar(
      jar: AbsolutePath,
      dialect: Dialect
  ): List[(String, AbsolutePath)] =
    tryRun(
      List.empty, {
        try {
          if (sourceJars.addEntry(jar)) {
            FileIO.withJarFileSystem(jar, create = false) { root =>
              root.listRecursive.toList.flatMap {
                case source if source.isScala =>
                  addSourceFile(source, None, dialect).map(sym => (sym, source))
                case _ =>
                  List.empty
              }
            }
          } else
            List.empty
        } catch {
          case e: ZipError =>
            onError(InvalidJarException(jar, e))
            List.empty
        }
      }
    )

  // Used to add cached toplevel symbols to index
  def addIndexedSourceJar(
      jar: AbsolutePath,
      symbols: List[(String, AbsolutePath)]
  ): Unit = {
    if (sourceJars.addEntry(jar)) {
      symbols.foreach { case (sym, path) =>
        val acc = toplevels.getOrElse(sym, Set.empty)
        toplevels(sym) = acc + path
      }
    }
  }

  // Enters nontrivial toplevel symbols for Scala source files.
  // All other symbols can be inferred on the fly.
  override def addSourceFile(
      source: AbsolutePath,
      sourceDirectory: Option[AbsolutePath],
      dialect: Dialect
  ): List[String] =
    tryRun(
      List.empty, {
        indexedSources += 1
        val uri = source.toIdeallyRelativeURI(sourceDirectory)
        val symbols = indexSource(source, uri, dialect)
        symbols.foreach { symbol =>
          val acc = toplevels.getOrElse(symbol, Set.empty)
          toplevels(symbol) = acc + source
        }
        symbols
      }
    )

  private def indexSource(
      source: AbsolutePath,
      uri: String,
      dialect: Dialect
  ): List[String] = {
    val text = FileIO.slurp(source, StandardCharsets.UTF_8)
    val input = Input.VirtualFile(uri, text)
    val sourceToplevels = mtags.toplevels(input, dialect)
    if (source.isAmmoniteScript)
      sourceToplevels
    else
      sourceToplevels.filter(sym => !isTrivialToplevelSymbol(uri, sym))
  }

  def addToplevelSymbol(
      path: String,
      source: AbsolutePath,
      toplevel: String
  ): Unit = {
    if (source.isAmmoniteScript || !isTrivialToplevelSymbol(path, toplevel)) {
      val acc = toplevels.getOrElse(toplevel, Set.empty)
      toplevels(toplevel) = acc + source
    }
  }

  private def tryRun[A](fallback: => A, thunk: => A): A =
    try thunk
    catch onError.andThen(_ => fallback)

  // Returns true if symbol is com/foo/Bar# and path is /com/foo/Bar.scala
  // Such symbols are "trivial" because their definition location can be computed
  // on the fly.
  private def isTrivialToplevelSymbol(path: String, symbol: String): Boolean = {
    val pathBuffer =
      CharBuffer.wrap(path).subSequence(1, path.length - ".scala".length)
    val symbolBuffer =
      CharBuffer.wrap(symbol).subSequence(0, symbol.length - 1)
    pathBuffer.equals(symbolBuffer)
  }

  // similar as addSourceFile except indexes all global symbols instead of
  // only non-trivial toplevel symbols.
  private def addMtagsSourceFile(file: AbsolutePath): Unit = {
    val docs: s.TextDocuments = PathIO.extension(file.toNIO) match {
      case "scala" | "java" | "sc" =>
        val language = file.toLanguage
        val toIndexSource0 = toIndexSource(file).getOrElse(file)
        val input = toIndexSource0.toInput
        val document = mtags.index(language, input)
        s.TextDocuments(List(document))
      case _ =>
        s.TextDocuments(Nil)
    }
    if (docs.documents.nonEmpty) {
      addTextDocuments(file, docs)
    }
  }

  // Records all global symbol definitions.
  private def addTextDocuments(
      file: AbsolutePath,
      docs: s.TextDocuments
  ): Unit = {
    docs.documents.foreach { document =>
      document.occurrences.foreach { occ =>
        if (occ.symbol.isGlobal && occ.role.isDefinition) {
          val acc = definitions.getOrElse(occ.symbol, Set.empty)
          definitions.put(occ.symbol, acc + file)
        } else {
          // do nothing, we only care about global symbol definitions.
        }
      }
    }
  }

  /**
   * Returns the file where symbol is defined, if any.
   *
   * Uses two strategies to recover from missing symbol definitions:
   * - try to enter the toplevel symbol definition, then lookup symbol again.
   * - if the symbol is synthetic, for examples from a case class of macro annotation,
   *  fall back to related symbols from the enclosing class, see `DefinitionAlternatives`.
   *
   * @param querySymbol The original symbol that was queried by the user.
   * @param symbol The symbol that
   * @return
   */
  private def findSymbolDefinition(
      querySymbol: Symbol,
      symbol: Symbol
  ): List[SymbolDefinition] = {
    if (!definitions.contains(symbol.value)) {
      // Fallback 1: enter the toplevel symbol definition
      val toplevel = symbol.toplevel
      toplevels.get(toplevel.value) match {
        case Some(files) =>
          files.foreach(addMtagsSourceFile)
        case _ =>
          loadFromSourceJars(trivialPaths(toplevel))
            .orElse(loadFromSourceJars(modulePaths(toplevel)))
            .foreach(_.foreach(addMtagsSourceFile))
      }
    }
    if (!definitions.contains(symbol.value)) {
      // Fallback 2: guess related symbols from the enclosing class.
      DefinitionAlternatives(symbol)
        .flatMap(alternative => findSymbolDefinition(querySymbol, alternative))
    } else {
      definitions
        .get(symbol.value)
        .map { paths =>
          paths.map { p =>
            SymbolDefinition(
              querySymbol = querySymbol,
              definitionSymbol = symbol,
              path = p
            )
          }.toList
        }
        .getOrElse(List.empty)
    }
  }

  // Returns the first path that resolves to a file.
  private def loadFromSourceJars(
      paths: List[String]
  ): Option[List[AbsolutePath]] = {
    paths match {
      case Nil => None
      case head :: tail =>
        sourceJars.loadAll(head) match {
          case Nil => loadFromSourceJars(tail)
          case values => Some(values)
        }
    }
  }

  // Returns relative file paths for trivial toplevel symbols, example:
  // Input:  scala/collection/immutable/List#
  // Output: scala/collection/immutable/List.scala
  //         scala/collection/immutable/List.java
  private def trivialPaths(toplevel: Symbol): List[String] = {
    val noExtension = toplevel.value.stripSuffix(".").stripSuffix("#")
    List(
      noExtension + ".scala",
      noExtension + ".java"
    )
  }

  private def modulePaths(toplevel: Symbol): List[String] = {
    if (Properties.isJavaAtLeast("9")) {
      val noExtension = toplevel.value.stripSuffix(".").stripSuffix("#")
      val javaSymbol = noExtension.replace("/", ".")
      try {
        for {
          cls <- sourceJars.loadClass(javaSymbol).toList
          // note(@tgodzik) Modules are only available in Java 9+, so we need to invoke this reflectively
          module <- Option(
            cls.getClass().getMethod("getModule").invoke(cls)
          ).toList
          moduleName <- Option(
            module.getClass().getMethod("getName").invoke(module)
          ).toList
          file <- List(
            s"$moduleName/$noExtension.java",
            s"$moduleName/$noExtension.scala"
          )
        } yield file
      } catch {
        case NonFatal(t) =>
          onError.lift(t)
          Nil
      }
    } else {
      Nil
    }
  }

}

object OnDemandSymbolIndex {
  def apply(
      toplevels: TrieMap[String, Set[AbsolutePath]] = TrieMap.empty,
      definitions: TrieMap[String, Set[AbsolutePath]] = TrieMap.empty,
      onError: PartialFunction[Throwable, Unit] = PartialFunction.empty,
      toIndexSource: AbsolutePath => Option[AbsolutePath] = _ => None
  ): OnDemandSymbolIndex =
    new OnDemandSymbolIndex(
      toplevels,
      definitions,
      onError,
      toIndexSource
    )
}
